#}
# Identify regions which overlap permitted_target_regions is provided
# if(!is.null(permitted_target_regions)){
target_regions_overlaps = GenomicRanges::countOverlaps(liftover_ranges, permitted_target_regions)
non_target_overlaps = which(target_regions_overlaps < 1)
print(paste(length(non_target_overlaps), "site not overlapping permitted target regions removed"))
selected_ranges = setdiff(selected_ranges, non_target_overlaps)
# }
# Subset meth_rse for selected rows and update rowRanges
meth_rse = meth_rse[selected_ranges, ]
rowRanges(meth_rse) = liftover_ranges[selected_ranges]
SummarizedExperiment::rowRanges(meth_rse) = unlist(SummarizedExperiment::rowRanges(meth_rse)) #
# # Flatten rowRanges if specified and there are no one-to-many mappings
# if(flatten_ranges & length(unlist(rowRanges(meth_rse))) == length(rowRanges(meth_rse))){
#   rowRanges(meth_rse) = unlist(rowRanges(meth_rse))
# }
# Return meth_rse
return(meth_rse)
}
tcga_meth_rse_hg38 = liftover_meth_rse(tcga_meth_rse_hg19, hg19tohg38_chain)
#' @param remove_one_to_many_mapping A logical value indicating whether to remove regions in the source genome
#' which map to multiple regions in the target genome. Default is TRUE.
#' @param remove_many_to_one_mapping A logical value indicating whether to remove different regions in the source genome
#' which map to the same region in the target genome i.e. remove regions which overlap after the liftover. Default is TRUE.
#' @param permitted_target_regions An optional GRanges object used to filter the rowRanges by overlaps after liftover,
#' for example CpG sites from the target genome. Any regions which do not overlap permitted_target_regions will be removed.
#' @param flatten_ranges A logical value indicating whether to convert the lifted over ranges from a
#' GRangesList to GRanges if all remaining source regions can be uniquely mapped to the target genome.
#' @return A RangedSummarizedExperiment with rowRanges lifted over to the genome build indicated by chain.
#' @export
liftover_meth_rse = function(meth_rse, chain, remove_non_mapping = T, remove_one_to_many_mapping = T,
remove_many_to_one_mapping = T, permitted_target_regions = NULL, flatten_ranges = T){
# Liftover rowRanges for meth_rse using specified liftover chain file
liftover_ranges = rtracklayer::liftOver(SummarizedExperiment::rowRanges(meth_rse), chain)
# Put seqlevels of liftover_ranges in the same order as meth_rse
GenomeInfoDb::seqlevels(liftover_ranges) = GenomeInfoDb::seqlevels(meth_rse)
# Initialize selected regions to all liftover_ranges
selected_ranges = seq_along(liftover_ranges)
# Get the number of regions in the target genome each region in the source genome matches to
mappings_count = lengths(liftover_ranges)
# Remove non-mapping regions from selected_ranges if specified
#if(remove_non_mapping){
non_mapping_regions = which(mappings_count == 0)
print(paste(length(non_mapping_regions), "non-mapping sites removed"))
selected_ranges = setdiff(selected_ranges, non_mapping_regions)
#}
# Remove one-to-many mapping regions from selected_ranges if specified
#if(remove_one_to_many_mapping){
one_to_many_mapping_regions = which(mappings_count > 1)
print(paste(length(one_to_many_mapping_regions), "one-to-many sites removed"))
selected_ranges = setdiff(selected_ranges, one_to_many_mapping_regions)
#}
# Remove many-to-one mapping regions from selected_ranges if specified
#if(remove_many_to_one_mapping){
self_overlaps = GenomicRanges::countOverlaps(liftover_ranges, liftover_ranges)
many_to_one_mapping_regions = which(self_overlaps > 1)
print(paste(length(many_to_one_mapping_regions), "many-to-one sites removed"))
selected_ranges = setdiff(selected_ranges, many_to_one_mapping_regions)
#}
# Identify regions which overlap permitted_target_regions is provided
if(!is.null(permitted_target_regions)){
target_regions_overlaps = GenomicRanges::countOverlaps(liftover_ranges, permitted_target_regions)
non_target_overlaps = which(target_regions_overlaps < 1)
print(paste(length(non_target_overlaps), "site not overlapping permitted target regions removed"))
selected_ranges = setdiff(selected_ranges, non_target_overlaps)
}
# Subset meth_rse for selected rows and update rowRanges
meth_rse = meth_rse[selected_ranges, ]
rowRanges(meth_rse) = liftover_ranges[selected_ranges]
SummarizedExperiment::rowRanges(meth_rse) = unlist(SummarizedExperiment::rowRanges(meth_rse)) #
# # Flatten rowRanges if specified and there are no one-to-many mappings
# if(flatten_ranges & length(unlist(rowRanges(meth_rse))) == length(rowRanges(meth_rse))){
#   rowRanges(meth_rse) = unlist(rowRanges(meth_rse))
# }
# Return meth_rse
return(meth_rse)
}
tcga_meth_rse_hg38 = liftover_meth_rse(tcga_meth_rse_hg19, hg19tohg38_chain)
meth_rse = tcga_meth_rse_hg19
chain = hg19tohg38_chain
remove_non_mapping = T
remove_one_to_many_mapping = T
remove_many_to_one_mapping = T
permitted_target_regions = NULL
# Liftover rowRanges for meth_rse using specified liftover chain file
liftover_ranges = rtracklayer::liftOver(SummarizedExperiment::rowRanges(meth_rse), chain)
# Put seqlevels of liftover_ranges in the same order as meth_rse
GenomeInfoDb::seqlevels(liftover_ranges) = GenomeInfoDb::seqlevels(meth_rse)
# Initialize selected regions to all liftover_ranges
selected_ranges = seq_along(liftover_ranges)
# Get the number of regions in the target genome each region in the source genome matches to
mappings_count = lengths(liftover_ranges)
# Remove non-mapping regions from selected_ranges if specified
#if(remove_non_mapping){
non_mapping_regions = which(mappings_count == 0)
message(paste(length(non_mapping_regions), "non-mapping sites removed"))
selected_ranges = setdiff(selected_ranges, non_mapping_regions)
# Remove one-to-many mapping regions from selected_ranges if specified
#if(remove_one_to_many_mapping){
one_to_many_mapping_regions = which(mappings_count > 1)
message(paste(length(one_to_many_mapping_regions), "one-to-many sites removed"))
selected_ranges = setdiff(selected_ranges, one_to_many_mapping_regions)
# Remove many-to-one mapping regions from selected_ranges if specified
#if(remove_many_to_one_mapping){
self_overlaps = GenomicRanges::countOverlaps(liftover_ranges, liftover_ranges)
many_to_one_mapping_regions = which(self_overlaps > 1)
message(paste(length(many_to_one_mapping_regions), "many-to-one sites removed"))
selected_ranges = setdiff(selected_ranges, many_to_one_mapping_regions)
# Identify regions which overlap permitted_target_regions is provided
if(!is.null(permitted_target_regions)){
target_regions_overlaps = GenomicRanges::countOverlaps(liftover_ranges, permitted_target_regions)
non_target_overlaps = which(target_regions_overlaps < 1)
message(paste(length(non_target_overlaps), "site not overlapping permitted target regions removed"))
selected_ranges = setdiff(selected_ranges, non_target_overlaps)
}
# Subset meth_rse for selected rows and update rowRanges
meth_rse = meth_rse[selected_ranges, ]
class(liftover_ranges[selected_ranges])
length(rowRanges(meth_rse))
length(SummarizedExperiment::rowRanges(meth_rse))
length(liftover_ranges[selected_ranges])
#' @param remove_one_to_many_mapping A logical value indicating whether to remove regions in the source genome
#' which map to multiple regions in the target genome. Default is TRUE.
#' @param remove_many_to_one_mapping A logical value indicating whether to remove different regions in the source genome
#' which map to the same region in the target genome i.e. remove regions which overlap after the liftover. Default is TRUE.
#' @param permitted_target_regions An optional GRanges object used to filter the rowRanges by overlaps after liftover,
#' for example CpG sites from the target genome. Any regions which do not overlap permitted_target_regions will be removed.
#' @param flatten_ranges A logical value indicating whether to convert the lifted over ranges from a
#' GRangesList to GRanges if all remaining source regions can be uniquely mapped to the target genome.
#' @return A RangedSummarizedExperiment with rowRanges lifted over to the genome build indicated by chain.
#' @export
liftover_meth_rse = function(meth_rse, chain, remove_non_mapping = T, remove_one_to_many_mapping = T,
remove_many_to_one_mapping = T, permitted_target_regions = NULL, flatten_ranges = T){
# Liftover rowRanges for meth_rse using specified liftover chain file
liftover_ranges = rtracklayer::liftOver(SummarizedExperiment::rowRanges(meth_rse), chain)
# Put seqlevels of liftover_ranges in the same order as meth_rse
GenomeInfoDb::seqlevels(liftover_ranges) = GenomeInfoDb::seqlevels(meth_rse)
# Initialize selected regions to all liftover_ranges
selected_ranges = seq_along(liftover_ranges)
# Get the number of regions in the target genome each region in the source genome matches to
mappings_count = lengths(liftover_ranges)
# Remove non-mapping regions from selected_ranges if specified
#if(remove_non_mapping){
non_mapping_regions = which(mappings_count == 0)
message(paste(length(non_mapping_regions), "non-mapping sites removed"))
selected_ranges = setdiff(selected_ranges, non_mapping_regions)
#}
# Remove one-to-many mapping regions from selected_ranges if specified
#if(remove_one_to_many_mapping){
one_to_many_mapping_regions = which(mappings_count > 1)
message(paste(length(one_to_many_mapping_regions), "one-to-many sites removed"))
selected_ranges = setdiff(selected_ranges, one_to_many_mapping_regions)
#}
# Remove many-to-one mapping regions from selected_ranges if specified
#if(remove_many_to_one_mapping){
self_overlaps = GenomicRanges::countOverlaps(liftover_ranges, liftover_ranges)
many_to_one_mapping_regions = which(self_overlaps > 1)
message(paste(length(many_to_one_mapping_regions), "many-to-one sites removed"))
selected_ranges = setdiff(selected_ranges, many_to_one_mapping_regions)
#}
# Identify regions which overlap permitted_target_regions is provided
if(!is.null(permitted_target_regions)){
target_regions_overlaps = GenomicRanges::countOverlaps(liftover_ranges, permitted_target_regions)
non_target_overlaps = which(target_regions_overlaps < 1)
message(paste(length(non_target_overlaps), "site not overlapping permitted target regions removed"))
selected_ranges = setdiff(selected_ranges, non_target_overlaps)
}
# Subset meth_rse for selected rows and update rowRanges
meth_rse = meth_rse[selected_ranges, ]
SummarizedExperiment::rowRanges(meth_rse) = unlist(liftover_ranges[selected_ranges]) #
# # Flatten rowRanges if specified and there are no one-to-many mappings
# if(flatten_ranges & length(unlist(rowRanges(meth_rse))) == length(rowRanges(meth_rse))){
#   rowRanges(meth_rse) = unlist(rowRanges(meth_rse))
# }
# Return meth_rse
return(meth_rse)
}
tcga_meth_rse_hg38 = liftover_meth_rse(meth_rse = tcga_meth_rse_hg19, chain = hg19tohg38_chain)
# Get CpG sites in hg38
hg38_cpgs = methodical:::cpg_genome_ranges_hg38
tcga_meth_rse_hg38 = liftover_meth_rse(meth_rse = tcga_meth_rse_hg19, chain = hg19tohg38_chain,
permitted_target_regions = hg38_cpgs)
#' @param remove_one_to_many_mapping A logical value indicating whether to remove regions in the source genome
#' which map to multiple regions in the target genome. Default is TRUE.
#' @param remove_many_to_one_mapping A logical value indicating whether to remove different regions in the source genome
#' which map to the same region in the target genome i.e. remove regions which overlap after the liftover. Default is TRUE.
#' @param permitted_target_regions An optional GRanges object used to filter the rowRanges by overlaps after liftover,
#' for example CpG sites from the target genome. Any regions which do not overlap permitted_target_regions will be removed.
#' @param flatten_ranges A logical value indicating whether to convert the lifted over ranges from a
#' GRangesList to GRanges if all remaining source regions can be uniquely mapped to the target genome.
#' @return A RangedSummarizedExperiment with rowRanges lifted over to the genome build indicated by chain.
#' @export
liftover_meth_rse = function(meth_rse, chain, remove_non_mapping = T, remove_one_to_many_mapping = T,
remove_many_to_one_mapping = T, permitted_target_regions = NULL, flatten_ranges = T){
# Liftover rowRanges for meth_rse using specified liftover chain file
liftover_ranges = rtracklayer::liftOver(SummarizedExperiment::rowRanges(meth_rse), chain)
# Put seqlevels of liftover_ranges in the same order as meth_rse
GenomeInfoDb::seqlevels(liftover_ranges) = GenomeInfoDb::seqlevels(meth_rse)
# Initialize selected regions to all liftover_ranges
selected_ranges = seq_along(liftover_ranges)
# Get the number of regions in the target genome each region in the source genome matches to
mappings_count = lengths(liftover_ranges)
# Remove non-mapping regions from selected_ranges if specified
#if(remove_non_mapping){
non_mapping_regions = which(mappings_count == 0)
message(paste(length(non_mapping_regions), "non-mapping sites removed"))
selected_ranges = setdiff(selected_ranges, non_mapping_regions)
#}
# Remove one-to-many mapping regions from selected_ranges if specified
#if(remove_one_to_many_mapping){
one_to_many_mapping_regions = which(mappings_count > 1)
message(paste(length(one_to_many_mapping_regions), "one-to-many mapping sites removed"))
selected_ranges = setdiff(selected_ranges, one_to_many_mapping_regions)
#}
# Remove many-to-one mapping regions from selected_ranges if specified
#if(remove_many_to_one_mapping){
self_overlaps = GenomicRanges::countOverlaps(liftover_ranges, liftover_ranges)
many_to_one_mapping_regions = which(self_overlaps > 1)
message(paste(length(many_to_one_mapping_regions), "many-to-one mapping sites removed"))
selected_ranges = setdiff(selected_ranges, many_to_one_mapping_regions)
#}
# Identify regions which overlap permitted_target_regions is provided
if(!is.null(permitted_target_regions)){
target_regions_overlaps = GenomicRanges::countOverlaps(liftover_ranges, permitted_target_regions)
non_target_overlaps = which(target_regions_overlaps < 1)
message(paste(length(non_target_overlaps), "sites not overlapping permitted target regions removed"))
selected_ranges = setdiff(selected_ranges, non_target_overlaps)
}
# Subset meth_rse for selected rows and update rowRanges
meth_rse = meth_rse[selected_ranges, ]
SummarizedExperiment::rowRanges(meth_rse) = unlist(liftover_ranges[selected_ranges]) #
# # Flatten rowRanges if specified and there are no one-to-many mappings
# if(flatten_ranges & length(unlist(rowRanges(meth_rse))) == length(rowRanges(meth_rse))){
#   rowRanges(meth_rse) = unlist(rowRanges(meth_rse))
# }
# Return meth_rse
return(meth_rse)
}
tcga_meth_rse_hg38 = liftover_meth_rse(meth_rse = tcga_meth_rse_hg19, chain = hg19tohg38_chain,
permitted_target_regions = hg38_cpgs)
#' @param remove_one_to_many_mapping A logical value indicating whether to remove regions in the source genome
#' which map to multiple regions in the target genome. Default is TRUE.
#' @param remove_many_to_one_mapping A logical value indicating whether to remove different regions in the source genome
#' which map to the same region in the target genome i.e. remove regions which overlap after the liftover. Default is TRUE.
#' @param permitted_target_regions An optional GRanges object used to filter the rowRanges by overlaps after liftover,
#' for example CpG sites from the target genome. Any regions which do not overlap permitted_target_regions will be removed.
#' @param flatten_ranges A logical value indicating whether to convert the lifted over ranges from a
#' GRangesList to GRanges if all remaining source regions can be uniquely mapped to the target genome.
#' @return A RangedSummarizedExperiment with rowRanges lifted over to the genome build indicated by chain.
#' @export
liftover_meth_rse = function(meth_rse, chain, remove_non_mapping = T, remove_one_to_many_mapping = T,
remove_many_to_one_mapping = T, permitted_target_regions = NULL, flatten_ranges = T){
# Liftover rowRanges for meth_rse using specified liftover chain file
liftover_ranges = rtracklayer::liftOver(SummarizedExperiment::rowRanges(meth_rse), chain)
# Put seqlevels of liftover_ranges in the same order as meth_rse
GenomeInfoDb::seqlevels(liftover_ranges) = GenomeInfoDb::seqlevels(meth_rse)
# Initialize selected regions to all liftover_ranges
selected_ranges = seq_along(liftover_ranges)
# Get the number of regions in the target genome each region in the source genome matches to
mappings_count = lengths(liftover_ranges)
# Remove non-mapping regions from selected_ranges if specified
#if(remove_non_mapping){
non_mapping_regions = which(mappings_count == 0)
message(paste(length(non_mapping_regions), "non-mapping sites removed"))
selected_ranges = setdiff(selected_ranges, non_mapping_regions)
#}
# Remove one-to-many mapping regions from selected_ranges if specified
if(remove_one_to_many_mapping){
one_to_many_mapping_regions = which(mappings_count > 1)
message(paste(length(one_to_many_mapping_regions), "one-to-many mapping sites removed"))
selected_ranges = setdiff(selected_ranges, one_to_many_mapping_regions)
}
# Remove many-to-one mapping regions from selected_ranges if specified
#if(remove_many_to_one_mapping){
self_overlaps = GenomicRanges::countOverlaps(liftover_ranges, liftover_ranges)
many_to_one_mapping_regions = which(self_overlaps > 1)
message(paste(length(many_to_one_mapping_regions), "many-to-one mapping sites removed"))
selected_ranges = setdiff(selected_ranges, many_to_one_mapping_regions)
#}
# Identify regions which overlap permitted_target_regions is provided
if(!is.null(permitted_target_regions)){
target_regions_overlaps = GenomicRanges::countOverlaps(liftover_ranges, permitted_target_regions)
non_target_overlaps = which(target_regions_overlaps < 1)
message(paste(length(non_target_overlaps), "sites not overlapping permitted target regions removed"))
selected_ranges = setdiff(selected_ranges, non_target_overlaps)
}
# Subset meth_rse for selected rows and update rowRanges
meth_rse = meth_rse[selected_ranges, ]
SummarizedExperiment::rowRanges(meth_rse) = unlist(liftover_ranges[selected_ranges]) #
# # Flatten rowRanges if specified and there are no one-to-many mappings
# if(flatten_ranges & length(unlist(rowRanges(meth_rse))) == length(rowRanges(meth_rse))){
#   rowRanges(meth_rse) = unlist(rowRanges(meth_rse))
# }
# Return meth_rse
return(meth_rse)
}
tcga_meth_rse_hg38 = liftover_meth_rse(meth_rse = tcga_meth_rse_hg19, chain = hg19tohg38_chain,
permitted_target_regions = hg38_cpgs)
#'
#' @param meth_rse A RangedSummarizedExperiment for methylation data
#' @param chain A "Chain" object to be used with rtracklayer::liftOver
#' @param remove_one_to_many_mapping A logical value indicating whether to remove regions in the source genome
#' which map to multiple regions in the target genome. Default is TRUE.
#' @param permitted_target_regions An optional GRanges object used to filter the rowRanges by overlaps after liftover,
#' for example CpG sites from the target genome. Any regions which do not overlap permitted_target_regions will be removed.
#' GRangesList to GRanges if all remaining source regions can be uniquely mapped to the target genome.
#' @return A RangedSummarizedExperiment with rowRanges lifted over to the genome build indicated by chain.
#' @export
liftover_meth_rse = function(meth_rse, chain, remove_one_to_many_mapping = T, permitted_target_regions = NULL){
# Liftover rowRanges for meth_rse using specified liftover chain file
liftover_ranges = rtracklayer::liftOver(SummarizedExperiment::rowRanges(meth_rse), chain)
# Put seqlevels of liftover_ranges in the same order as meth_rse
GenomeInfoDb::seqlevels(liftover_ranges) = GenomeInfoDb::seqlevels(meth_rse)
# Initialize selected regions to all liftover_ranges
selected_ranges = seq_along(liftover_ranges)
# Get the number of regions in the target genome each region in the source genome matches to
mappings_count = lengths(liftover_ranges)
# Remove non-mapping regions from selected_ranges if specified
non_mapping_regions = which(mappings_count == 0)
message(paste(length(non_mapping_regions), "non-mapping sites removed"))
selected_ranges = setdiff(selected_ranges, non_mapping_regions)
# Remove one-to-many mapping regions from selected_ranges if specified
if(remove_one_to_many_mapping){
one_to_many_mapping_regions = which(mappings_count > 1)
message(paste(length(one_to_many_mapping_regions), "one-to-many mapping sites removed"))
selected_ranges = setdiff(selected_ranges, one_to_many_mapping_regions)
}
# Remove many-to-one mapping regions from selected_ranges if specified
self_overlaps = GenomicRanges::countOverlaps(liftover_ranges, liftover_ranges)
many_to_one_mapping_regions = which(self_overlaps > 1)
message(paste(length(many_to_one_mapping_regions), "many-to-one mapping sites removed"))
selected_ranges = setdiff(selected_ranges, many_to_one_mapping_regions)
# Identify regions which overlap permitted_target_regions is provided
if(!is.null(permitted_target_regions)){
target_regions_overlaps = GenomicRanges::countOverlaps(liftover_ranges, permitted_target_regions)
non_target_overlaps = which(target_regions_overlaps < 1)
message(paste(length(non_target_overlaps), "sites not overlapping permitted target regions removed"))
selected_ranges = setdiff(selected_ranges, non_target_overlaps)
}
# Subset meth_rse for selected rows and update rowRanges
meth_rse = meth_rse[selected_ranges, ]
SummarizedExperiment::rowRanges(meth_rse) = unlist(liftover_ranges[selected_ranges]) #
# Return meth_rse
return(meth_rse)
}
# Liftover tcga_meth_rse_hg19 to hg38
tcga_meth_rse_hg38 = liftover_meth_rse(meth_rse = tcga_meth_rse_hg19, chain = hg19tohg38_chain,
permitted_target_regions = hg38_cpgs)
?cor
message(paste("Using", match.arg(cor_method, c("pearson", "kendall", "spearman")), "correlation method"))
cor_method = "kend"
message(paste("Using", match.arg(cor_method, c("pearson", "kendall", "spearman")), "correlation method"))
cor_method = "p"
message(paste("Using", match.arg(cor_method, c("pearson", "kendall", "spearman")), "correlation method"))
cor_method = "sp"
message(paste("Using", match.arg(cor_method, c("pearson", "kendall", "spearman")), "correlation method"))
80000^2
colnames(mtcars)
names(mtcars)
names(as.matrix(mtcars))
library(dplyr)
select(mtcars, all_of(c("vs", disp", "carb)))
select(mtcars, all_of(c("vs", "disp", "carb")))
head(select(mtcars, any_of(c("vs", "disp", "carb"))))
ls()
x=ls()
load("~/my_packages/methodical/R/sysdata.rda")
y=ls()
setdiff(y, x)
x
methodical::cpg_genome_ranges_hg19
methodical::cpg_genome_ranges_hg38
methodical::infinium_450k_probe_granges_hg19
methodical::infinium_450k_probe_granges_hg38
od = getwd()
setwd(2~/mount/hpcn)
setwd("~/mounts/hpcnfs_mount/scratch/MS/tcga_methylation/tcga_wgbs/)
setwd("~/mounts/hpcnfs_mount/scratch/MS/tcga_methylation/tcga_wgbs/")
# Get paths t BAM files
bam_files = list.files("rnaseq_bams/")
bam_files
# Get paths t BAM files
bam_files = list.files("rnaseq_bams/", full.names = T)
# Load required packages
library(rnaR)
#
file_names = gsub(".transcriptome.gdc_realn.bam", "", basename(bam_files))
file_names
#
file_names = gsub(".rna_seq.transcriptome.gdc_realn.bam", "", basename(bam_files))
file_names
bam_files
# Get paths to BAM files
bam_files = list.files("rnaseq_bams", full.names = T)
#
file_names = gsub(".rna_seq.transcriptome.gdc_realn.bam", "", basename(bam_files))
bam_files
file_names
# Read manifest for TCGA TCGA methylation files
manifest = read.table("tcga_wgbs_rnaseq_manifest_2023_09_01.txt", header = T)
# Read in the JSON file as a list and turn it into a data.frame
json_file = rjson::fromJSON(file = "tcga_wgbs_rnaseq_json_2023_09_01.txt")
json_file = split(unname(unlist(json_file)), names(unlist(json_file)))
json_file_df = data.frame(json_file[setdiff(names(json_file), "annotations.annotation_id")])
# Remove TCGA- from project_id
json_file_df$cases.project.project_id = gsub("TCGA-", "", json_file_df$cases.project.project_id)
# Add the TCGA barcode using the file ID and then add submitter and sample type. 5 submitters have 2 primary tumour samples and 6 have three primary tumour samples
manifest$barcode = TCGAutils::UUIDtoBarcode(manifest$id, from_type = c("file_id"))$associated_entities.entity_submitter_id
manifest$submitter = substr(manifest$barcode, start = 1, stop = 12)
manifest$sample_type = substr(manifest$barcode, start = 14, stop = 15)
# Add the project ID to the manifest from the JSON file
manifest$project = json_file_df$cases.project.project_id[match(manifest$filename, json_file_df$file_name)]
manifest
# Create sample metadata
sample_metadata = data.frame(select(manifest, barcode, submitter, sample_type, project, filename, id))
# Add a column combining submitter and sample type, arrange table by it and remove samples for duplicated submitter and sample type
sample_metadata$submitter_and_sample_type = paste(sample_metadata$submitter, sample_metadata$sample_type, sep = "_")
sample_metadata = arrange(sample_metadata, submitter_and_sample_type)
sample_metadata = filter(sample_metadata, !duplicated(submitter_and_sample_type))
# Change "-" in submitter_and_sample_type to "_"
sample_metadata$submitter_and_sample_type = gsub("-", "_", sample_metadata$submitter_and_sample_type)
head(sample_metadata)
# Save sample metadata table
data.table::fwrite(sample_metadata, "tcga_wgbs_rnaseq_files_metadata.tsv", sep = "\t", quote = F)
sample_metadata
# Get paths to BAM files
bam_files = list.files("rnaseq_bams", full.names = T)
sum(duplicated(sample_metadata$submitter_and_sample_type)
sum(duplicated(sample_metadata$submitter_and_sample_type))
setNames(sample_metadata$submitter_and_sample_type, sample_metadata$filename)[basename(bam_files)]
# Match the BAM files to submitter_and_sample_type from using the metadata
file_names = unname(setNames(sample_metadata$submitter_and_sample_type, sample_metadata$filename)[basename(bam_files)])
file_names
bam_files[3]
sample_metadata
sample_metadata
dim(manifest)
dim(sample_metadata)
# Create sample metadata
sample_metadata = data.frame(select(manifest, barcode, submitter, sample_type, project, filename, id))
dim(sample_metadata)
sample_metadata
# Add a column combining submitter and sample type, arrange table by it and remove samples for duplicated submitter and sample type
sample_metadata$submitter_and_sample_type = paste(sample_metadata$submitter, sample_metadata$sample_type, sep = "_")
sample_metadata = arrange(sample_metadata, submitter_and_sample_type)
sample_metadata
sum(duplicated(sample_metadata$submitter_and_sample_type))
which(duplicated(sample_metadata$submitter_and_sample_type))
# Create sample metadata
sample_metadata = data.frame(select(manifest, barcode, submitter, sample_type, project, filename, id))
# Add a column combining submitter and sample type, arrange table by it and remove samples for duplicated submitter and sample type
sample_metadata$submitter_and_sample_type = paste(sample_metadata$submitter, sample_metadata$sample_type, sep = "_")
sample_metadata = arrange(sample_metadata, submitter_and_sample_type)
dim(sample_metadata)
head(sample_metadata)
filter(sample_metadata, !(submitter == "TCGA-BL-A13J" &
filename == "7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam"))
!(submitter == "TCGA-BL-A13J" &
filename != "7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam")
filter(sample_metadata, !(submitter == "TCGA-BL-A13J" &
filename != "7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam"))
dim(sample_metadata)
filter(sample_metadata, (submitter == "TCGA-BL-A13J"))
dim(filter(sample_metadata, !(submitter == "TCGA-BL-A13J" &
filename != "7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam")))
dim(filter(sample_metadata, !(submitter == "TCGA-BL-A13J" &
filename == "7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam")))
filter(sample_metadata, !(submitter == "TCGA-BL-A13J" &
filename == "7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam"))
filter(sample_metadata, (submitter == "TCGA-BL-A13J" &
filename == "7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam"))
filter(sample_metadata, (submitter == "TCGA-BL-A13J" &
filename != "7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam"))
dim(filter(sample_metadata, !(submitter_and_sample_type == "TCGA-BL-A13J_01" &
filename != "7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam")))
# There are 3 BAM files for primary tumour samples from TCGA-BL-A13J so
# the biggest one (7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam) is selected.
sample_metadata = filter(sample_metadata, !(submitter_and_sample_type == "TCGA-BL-A13J_01" &
filename != "7cd8c835-cbce-4aa1-84d0-3ea7d3112630.rna_seq.transcriptome.gdc_realn.bam"))
filter(sample_metadata, submitter_and_sample_type == "TCGA-BL-A13J_01")
# Change "-" in submitter_and_sample_type to "_"
sample_metadata$submitter_and_sample_type = gsub("-", "_", sample_metadata$submitter_and_sample_type)
# Save sample metadata table
data.table::fwrite(sample_metadata, "tcga_wgbs_rnaseq_files_metadata.tsv", sep = "\t", quote = F)
# Get paths to BAM files
bam_files = list.files("rnaseq_bams", full.names = T)
names(bam_files) = basename(bam_files)
bam_files[sample_metadata$id]
sample_metadata
sample_metadata$id
bam_files[sample_metadata$filename]
length(bam_files[sample_metadata$filename])
all(basename(bam_files) == sample_metadata$filename)
dim(sample_metadata)
length(bam_files)
# Get paths to BAM files and put in the same order as the sample metadata
bam_files = list.files("rnaseq_bams", full.names = T)
names(bam_files) = basename(bam_files)
bam_files = bam_files[sample_metadata$filename]
length(bam_files)
all(basename(bam_files) == sample_metadata$filename)
sample_metadata = read.table("tcga_wgbs_rnaseq_files_metadata.tsv", sep = "\t")
sample_metadata
sample_metadata = read.table("tcga_wgbs_rnaseq_files_metadata.tsv", sep = "\t", col.names = T)
sample_metadata = data.table::fread("tcga_wgbs_rnaseq_files_metadata.tsv", sep = "\t", col.names = T)
sample_metadata = data.table::fread("tcga_wgbs_rnaseq_files_metadata.tsv")
sample_metadata
setwd(od)
tcga_plot
getwd()
ls()
q()
